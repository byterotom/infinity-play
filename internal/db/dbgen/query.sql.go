// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package dbgen

import (
	"context"
)

const addOne = `-- name: AddOne :one
INSERT INTO Game(
    id,name,description,technology,thumbnail_url,gif_url,game_url
) VALUES(
    ?,?,?,?,?,?,?
)
RETURNING id, name, description, technology, release_date, likes, votes, thumbnail_url, gif_url, game_url
`

type AddOneParams struct {
	ID           string
	Name         string
	Description  string
	Technology   string
	ThumbnailUrl string
	GifUrl       string
	GameUrl      string
}

func (q *Queries) AddOne(ctx context.Context, arg AddOneParams) (Game, error) {
	row := q.db.QueryRowContext(ctx, addOne,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Technology,
		arg.ThumbnailUrl,
		arg.GifUrl,
		arg.GameUrl,
	)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Technology,
		&i.ReleaseDate,
		&i.Likes,
		&i.Votes,
		&i.ThumbnailUrl,
		&i.GifUrl,
		&i.GameUrl,
	)
	return i, err
}

const getAll = `-- name: GetAll :many
SELECT id, name, description, technology, release_date, likes, votes, thumbnail_url, gif_url, game_url FROM Game
`

func (q *Queries) GetAll(ctx context.Context) ([]Game, error) {
	rows, err := q.db.QueryContext(ctx, getAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Technology,
			&i.ReleaseDate,
			&i.Likes,
			&i.Votes,
			&i.ThumbnailUrl,
			&i.GifUrl,
			&i.GameUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
